#pragma once
#include <Windows.h>
#include <iostream>
#include <string>
#include <fstream>
#include <iterator>
#include <vector>
#include <fstream>
#include <sstream>
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <WinINet.h>
#include <algorithm>
#include <random>
#include <ostream>
#include <chrono>
#include <typeinfo>
#include <fcntl.h>
#include <io.h>
#include <urlmon.h>
#include <stdio.h>
#include <TlHelp32.h>
#include <wininet.h>
#include <Shlwapi.h>
#include <tchar.h>
#include <typeinfo>
#include <WinInet.h>
#include <fstream>
#include <algorithm>
#include <Psapi.h>
#include <tlhelp32.h>
#include <math.h>
#include <cmath>

using namespace std; //this is used for defining string functions


inline long AddyScan(long Address) { //this function reads the addresses aka makes them usable
	return (Address - 0x400000 + (DWORD)GetModuleHandle(NULL));
}

DWORD CheckBypass(DWORD addr)
{
	BYTE* tAddr = (BYTE*)addr;

	/* Calcualte the size of the function
	In theory this will run until it hits the next
	functions prolog. It assumes all calls are aligned to
	16 bytes. (grazie katie)
	*/
	do
	{
		tAddr += 16;
	} while (!(tAddr[0] == 0x55 && tAddr[1] == 0x8B && tAddr[2] == 0xEC));

	DWORD funcSz = tAddr - (BYTE*)addr;

	/* Allocate memory for the new function */
	PVOID nFunc = VirtualAlloc(NULL, funcSz, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (nFunc == NULL)
		return addr;

	/* Copy the function to the newly allocated memory */
	memcpy(nFunc, (void*)addr, funcSz);

	BYTE* pos = (BYTE*)nFunc;
	BOOL valid = false;
	do
	{
		/* Check for the return check with the sig:
		72 ?? A1 ?? ?? ?? ?? 8B
		If the sig matches replace the the jb with a jmp.
		*/
		if (pos[0] == 0x72 && pos[2] == 0xA1 && pos[7] == 0x8B) {
			*(BYTE*)pos = 0xEB;

			DWORD cByte = (DWORD)nFunc;
			do
			{
				/* Check if the current byte is a call if it is,
				calculate the new relative call(s).
				*(->E8 + 1) = originalFunction - nextInstruction

				oFuncPos - Position of call in original function
				= originalFunction + (->E8 - newFunction)

				oFuncAddr - Original call location
				= oFuncPos + rel32Offset + sizeof(call)

				relativeAddr - New relative address
				= oFuncAddr - ->E8 - sizeof(call)

				Since we are not using a disassembler we assume
				that if we hit a E8 byte which is properly aligned
				it is a relative call.
				For a small amount of compensation I skip location
				of the call, since it is possible to have the byte
				E8 inside of it.
				*/
				if (*(BYTE*)cByte == 0xE8)
				{
					DWORD oFuncPos = addr + (cByte - (DWORD)nFunc);
					DWORD oFuncAddr = (oFuncPos + *(DWORD*)(oFuncPos + 1)) + 5;

					if (oFuncAddr % 16 == 0)
					{
						DWORD relativeAddr = oFuncAddr - cByte - 5;
						*(DWORD*)(cByte + 1) = relativeAddr;

						cByte += 4;
					}
				}

				cByte += 1;
			} while (cByte - (DWORD)nFunc < funcSz);

			valid = true;
		}
		pos += 1;
	} while ((DWORD)pos < (DWORD)nFunc + funcSz);

	/* This function has no return check, let's not waste memory */
	if (!valid)
	{
		VirtualFree(nFunc, funcSz, MEM_RELEASE);
		return addr;
	}

	return (DWORD)nFunc;
}

std::string ConvertToString(int i) { //error solved :)
	std::string returnval;
	if (i) {
		returnval = std::to_string(i);
	}
	return returnval;
} //function number one

std::vector<std::string> gay(std::string str, char Delim) { //error solved :D
	std::vector<std::string> Args;
	std::stringstream ss(str); //ok now these are the functions for cmds ok
	std::string Arg;
	while (getline(ss, Arg, Delim))
		Args.push_back(Arg);
	return Args;
}

std::string GetString() {
std::string input;
getline(std::cin, input);
return input;
}


std::string tostring(std::string str)
{
	std::string retn("");
	for (int i = 0; i < str.length(); i++)
	{
		int ascii = (int)str.at(i);
		if (ascii >= (int)'a' && ascii <= (int)'z')
			retn += (char)ascii;
		else
			retn += (char)(ascii + ((int)'a' - (int)'A'));
	}
	return retn;
}

std::string GetInput() {
	std::string input;
	getline(std::cin, input);
	return input; 
}

bool CompareData(const char* Data, const char* Mask1, const char* Mask2) {
	while (*Mask2) {
		if (*Mask2 != '?') {
			if (*Data != *Mask1) {
				return false;
			};
		};
		++Mask2;
		++Data;
		++Mask1;
	};
	return true;
};


DWORD ScanForScriptContext(const char* ScriptContextVFTable) { // script context scanner thingie
	MEMORY_BASIC_INFORMATION MemoryInformation = { NULL };
	SYSTEM_INFO SystemInfo = { NULL };
	GetSystemInfo(&SystemInfo);
	DWORD StartPosition = (DWORD)SystemInfo.lpMinimumApplicationAddress;
	DWORD EndPosition = (DWORD)SystemInfo.lpMaximumApplicationAddress;
	do {
		while (VirtualQuery((void*)StartPosition, &MemoryInformation, sizeof(MemoryInformation))) {
			if ((MemoryInformation.Protect & PAGE_READWRITE) && !(MemoryInformation.Protect & PAGE_GUARD)) {
				for (
					DWORD Key = (DWORD)(MemoryInformation.BaseAddress);
					((Key - (DWORD)(MemoryInformation.BaseAddress)) < MemoryInformation.RegionSize);
					++Key
					) {
					if (CompareData((const char*)Key, ScriptContextVFTable, "xxxx")) {
						return Key;
					};
				};
			};
			StartPosition += MemoryInformation.RegionSize;
		};
	} while (StartPosition < EndPosition);
	return NULL;
};

